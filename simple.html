<!DOCTYPE html>
<html>
  <head>
    <title>Briefcase!!</title>
    <style rel="stylesheet" type="text/css">
      
      @keyframes wobbly {
        10% { transform: rotate(4deg); }
        30% { transform: rotate(-4deg); }
        60% { transform: rotate(6deg); }
        70% { transform: rotate(-3deg); }
        85% { transform: rotate(3deg); }
        100% { transform: rotate(-6deg); }
      }
      
      html, body {
        position: fixed;
        left: 0; top: 0;
        width: 100%; height: 100%;
        margin: 0; padding: 0;
        background-color: #a8a8a8;
        font-family: sans-serif;
        user-select: none;
      }
      .snackControl {
        position: absolute;
        width: 400px; height: 400px;
        left: 50%; top: 50%;
        margin-left: -200px; margin-top: -200px;
        box-shadow: 0 0 0 10px #000000;
        background-color: #ffffff;
        z-index: 1;
      }
      .snackControl > .loading {
        position: absolute;
        left: 0; top: 0;
        width: 400px; height: 400px; line-height: 400px;
        font-size: 24px;
        text-align: center;
        background-color: #ffffff;
      }
      .snackControl > .available, .snackControl > .inserted {
        position: absolute;
      }
      .snackControl > .available {
        width: 50%; height: 100%;
        left: 0;
      }
      .snackControl > .inserted {
        width: 50%; height: 100%;
        right: 0;
      }
      .snack {
        position: relative;
        background-color: rgba(0, 0, 0, 0.3);
        width: 100%; height: 30px; line-height: 30px;
        text-align: center;
        box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.4);
        overflow: hidden;
        white-space: nowrap;
        transition: opacity 1000ms ease-out;
        opacity: 1;
      }
      .snack > .text {
        position: absolute;
        width: 100%; height: 30px; line-height: 30px;
        color: #ffffff;
        z-index: 2;
      }
      .snack.waiting {
        opacity: 0.7;
        pointer-events: none;
        animation-name: wobbly;
        animation-iteration-count: infinite;
        animation-delay: 1000ms;
        animation-timing-function: ease-in-out;
        animation-duration: 400ms;
      }
      .snack:before {
        content: ''; display: block; position: absolute;
        width: 300px; height: 300px;
        left: -120px; top: 145px;
        margin-left: -250px; margin-top: -250px;
        transform: rotate(45deg);
        background-color: #000000;
        box-shadow: 0 0 20px 2px #000000;
        transition: left 300ms ease-in-out;
        z-index: 1;
      }
      .snack:hover:before { left: 150px; }
      .available > .snack:before { background-color: #00a010; box-shadow: 0 0 20px 2px #00a010; }
      .inserted > .snack:before { background-color: #c00000; box-shadow: 0 0 20px 2px #c00000; }
      
      .adminButton {
        position: absolute;
        right: 0;
        bottom: 0;
        width: 4px; height: 4px;
        background-color: #ffffff;
      }
      .admin {
        position: absolute;
        left: 100%; top: 100%;
        width: 480px; height: 480px;
        padding: 10px;
        margin-left: -250px; margin-top: -250px;
        transform: scale(0);
        background-color: rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 0 14px #000000;
        pointer-events: none;
        z-index: 2;
        text-align: center;
        
        transition: left 600ms ease-in-out, top 600ms ease-in-out, transform 600ms linear;
      }
      .admin.open {
        left: 50%; top: 50%;
        transform: scale(1);
        pointer-events: all;
        font-size: 0;
      }
      .admin > .availableContent {
        width: 472px; height: 400px;
        padding: 4px;
        resize: none;
        outline: none !important;
        border: none !important;
        background-color: rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.8);
        font-size: 14px;
      }
      .admin > .button {
        position: relative;
        width: 200px; height: 60px; line-height: 60px;
        font-size: 30px;
        margin: 10px auto 0;
        background-color: #102070;
        color: #ffffff;
        cursor: pointer;
      }
    </style>
    <script type="text/javascript">(async () => {
      let poll = async (cmd, params=null) => {
        let req = new XMLHttpRequest();
        req.open('GET', cmd, true);
        req.setRequestHeader('Content-Type', 'application/json');
        req.send(JSON.stringify(params));
        
        return new Promise(r => {
          req.onreadystatechange = () => {
            if (req.readyState !== 4) return;
            if (req.responseText.length === 0) return;
            try { r(JSON.parse(req.responseText)); } catch(err) { r(null); }
          };
        });
      };
      
      await new Promise(r => window.addEventListener('load', r));
      
      let div = c => { let d = document.createElement('div'); d.classList.add(c); return d; }
      
      let body = document.body;
      
      let snackControl = body.appendChild(div('snackControl'));
      let availableDom = snackControl.appendChild(div('available'));
      let insertedDom = snackControl.appendChild(div('inserted'));
      
      let adminOpen = false;
      let adminDom = body.appendChild(div('admin'));
      let adminAvailableContent = adminDom.appendChild(document.createElement('textarea'));
      adminAvailableContent.classList.add('availableContent');
      
      let adminUpdateButtonDom = adminDom.appendChild(div('button'))
      adminUpdateButtonDom.innerText = 'Update!';
      adminUpdateButtonDom.addEventListener('mousedown', async () => {
        try {
          let parsedAvail = JSON.parse(adminAvailableContent.value);
          let upd = await poll(`setAvailable?${encodeURIComponent(JSON.stringify(parsedAvail))}`);
          await update(upd);
          adminOpen = false;
          adminDom.classList.remove('open');
        } catch(err) {
          alert('bad!');
        }
      });
      
      let adminButtonDom = body.appendChild(div('adminButton'));
      adminButtonDom.addEventListener('mousedown', () => {
        adminDom.classList[adminOpen ? 'remove' : 'add']('open');
        adminOpen = !adminOpen;
        
        if (adminOpen) {
          let curAvail = {};
          for (let k in available) curAvail[k] = available[k].snackData;
          adminAvailableContent.value = JSON.stringify(curAvail, null, 2);
        }
      });
      
      let available = {};
      let updateAvailable = upd => {
        /*
        upd ~= {
          sweetChilliHeat: {
            name: 'Sweet Chilli Heat',
            price: 4.5,
            imageUrl: '/assets/img/sch.png'
          }
        }
        */
        
        // Remove snacks no longer available
        for (let [ snackId, snackData ] of Object.entries(available)) {
          if (!upd.hasOwnProperty(snackId)) {
            available[snackId].snackDom.parentNode.removeChild(available[snackId].snackDom);
            delete available[snackId];
          }
        }
        
        for (let [ snackId, snackData ] of Object.entries(upd)) {
          
          // Initial setup
          if (!available.hasOwnProperty(snackId)) {
            let snackDom = availableDom.appendChild(div('snack'));
            snackDom.classList.add(snackId);
            snackDom.snackId = snackId;
            let snackTextDom = snackDom.appendChild(div('text'));
            
            snackDom.addEventListener('mousedown', async () => {
              snackDom.classList.add('waiting');
              let upd = await poll(`addInserted?${snackDom.snackId}`); // Do the add
              await update(upd);
              snackDom.classList.remove('waiting');
            });
            available[snackId] = { snackData, snackDom };
          }
          
          available[snackId].snackData = snackData;
          available[snackId].snackDom.getElementsByClassName('text')[0].innerText = snackData.name;
        }
        
      };
      
      let inserted = {};
      let updateInserted = (snackCounts) => {
        
        // Remove any snacks that have dropped to 0
        for (let [ snackId, snackIns ] of Object.entries(inserted)) {
          if (!snackCounts.hasOwnProperty(snackId)) {
            snackIns.snackDom.parentNode.removeChild(snackIns.snackDom);
            delete inserted[snackId];
          }
        }
        
        for (let [ snackId, count ] of Object.entries(snackCounts)) {
          
          // Get data
          let snackData = available[snackId].snackData;
          
          // Initial setup
          if (!inserted.hasOwnProperty(snackId)) {
            
            // Create dom
            let snackDom = insertedDom.appendChild(div('snack'));
            snackDom.classList.add(snackId);
            let snackTextDom = snackDom.appendChild(div('text'));
            snackDom.snackId = snackId;
            snackDom.addEventListener('mousedown', async () => {
              snackDom.classList.add('waiting');
              let upd = await poll(`remInserted?${snackDom.snackId}`); // Do the removal
              await update(upd);
              snackDom.classList.remove('waiting');
            });
            
            inserted[snackId] = { snackData, snackDom, count: 0 };
            
          }
          
          // Update count and dom
          inserted[snackId].count = count;
          inserted[snackId].snackDom.getElementsByClassName('text')[0].innerText = `${snackData.name} (x ${count})`;
          
        }
        
      };
      
      let updateTimeout = null;
      let update = async (data) => {
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(update, 2000);
        if (!data) data = await poll('updateData');
        updateAvailable(data.available);
        updateInserted(data.inserted);
        return data;
      }
      
      let loading = snackControl.appendChild(div('loading'));
      loading.innerText = 'Loading...';
      
      await update();
      snackControl.removeChild(loading);
      
    })();</script>
  </head>
  <body>
  </body>
</html>
